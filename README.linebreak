unicode_linebreak - Uicode Line Breaking Module.

Copyright Â© 2006 by Hatuka*nezumi - IKEDA Soji <hatuka(at)nezumi.nu>,
redistributed under GNU General Public License version 2 (or later
version you prefer).

$Id$


Archive Contents
================

LineBreak/AmbiguousWidth.py      Customization info. of ambiguous char. width.
LineBreak/CharacterProperties.py Customization info. of character properties.
LineBreak/Rules.py               Customization info. of line breaking rules.
LineBreak/Utils.py               Utility functions for python.
LineBreak/__init__.py            Class placeholder.
README.linebreak                 This file.
linebreakrule.html               (*) Table to verify line breaking rules.
mklbproptab.py                   Python script to generate files marked (*).
tests/test-linebreak.c           Source of test application.
tests/testdata.txt               Test data with universal content.
unicode_linebreak.c              Main module.
unicode_linebreak.h              Main header file.
unicode_linebreaktab.c           (*) Data maps relating line breaking.
unicode_linebreaktab.h           (*) Sub header file.


Integration with Your Application
=================================

1. Prepare header file.

A header file `unicode.h' is required, in which `unicode_char' type
should be defined.  `unicode_char' holds UCS-4 ordinal number of
character.  For example:

    typedef wchar_t unicode_char;

2. Include a header.

At top of source of your application, insert following line:

    #include "unicode_linebreak.h"

3. Link modules.

Compile and link following source files to your application:

    unicode_linebreak.c
    unicode_linebreaktab.c


API
===

1. Header

#include "unicode_linebreak.h"

2. Public functions

struct unicode_lbinfo
*unicode_linebreak_alloc(unicode_char *text, size_t textlen,
                         unicode_lbprop_funcptr
                         (*find_lbprop_func)(const char *, int),
                         void (*tailor_lbprop)(unicode_char,
                                               int *, enum unicode_lbclass *,
                                               int),
                         const char *chset, int flags);

    Allocate line breaking informations for given unicode text.

    Arguments:
        text:
                Text to be broken.
        textlen:
                Length of `text'.
        find_lbprop_func:
                Function to get a function that get character properties
                of unicode character.  If NULL is specified, built-in
                function will be used.                
        tailor_lbprop:
                Function to tailor character property.  If NULL is specified,
                built-in function will be used.
        chset:
                Charset context.  This is fed to find_lbprop_func(), and
                may referred through `lbinfo' argument fed to
                is_line_exceeded() and writeout_cb().
        flags:
                Bitwise options to customize behavior of line breaking
                (see Option Flags).

    Returns:
        Pointer to allocated `struct unicode_lbinfo' data, line breaking
        informations for `text'.  If `text' is NULL, length of `text' is zero,
        or any error occur, NULL will be returned.

void unicode_linebreak_free(struct unicode_lbinfo *lbinfo);

    Free storage allocated by unicode_linebreak_alloc().

enum unicode_lbaction
unicode_linebreak(struct unicode_lbinfo *lbinfo, unicode_char *text,
                  int (*is_line_exceeded)(struct unicode_lbinfo *,
                                          unicode_char *,
                                          off_t, size_t, int),
                  void (*writeout_cb)(struct unicode_lbinfo *,
                                      unicode_char *,
                                      off_t, size_t, enum unicode_lbaction),
                  int maxlen, void *voidarg);

    Execute line breaking.

    Arguments:
        lbinfo:
                Line breaking informations.
        text:
                Array of unicode character to be broken.
        is_line_exceeded:
                Function to determin whether length of a text fragment
                exceeds the limit specified by `maxlen'.  If NULL is
                specified, built-in function will be used.
        writeout_cb:
                Callback function to write out each broken lines (see
                below).  If NULL is specified, unicode_do_linebreak()
                searches optimum line breaking points over text but
                never output anything.
        maxlen:
                Limit of line length.
        voidarg:
                A pointer to custom data structure passed to
                is_line_exceeded() and writeout_cb().  If you don't need
                custom data, set this NULL.

    Returns:
        UNICODE_LBACTION_NOMOD:
                No breaks or only explicit break(s) have occured.
        UNICODE_LBACTION_INDIRECT:
                Indirect break(s) have occured, but no direct breaks.
        UNICODE_LBACTION_DIRECT:
                Direct break(s) have occured, and possiblly Indirect
                breaks also.

    Callback function:
        void writeout_cb(struct unicode_lbinfo *lbinfo,
                         unicode_char *text, off_t start, size_t size,
                         enum unicode_lbaction action, void *voidarg);

        Called by unicode_linebreak() when breaking point is found then
        something to output exists.

        Arguments:
            lbinfo:
                    Line breaking informations.
            text:
                    Array of unicode character.
            start:
                    Offset of text fragment to output on text.
            size:
                    Length of text fragment to output.
            action:
                    Type of line breaking behavior:
                    UNICODE_LBACTION_EXPLICIT: Explicit break.
                    UNICODE_LBACTION_INDIRECT: Indirect break.
                    UNICODE_LBACTION_DIRECT:   Direct break.
                    UNICODE_LBACTION_EOT:      This line is the last line
                                               of `text'.
            voidarg:
                    A pointer to custom data structure passed from
                    unicode_linebreak().

        Note: Terminating newlines and spaces in the text will not be trimmed
          by calling function unicode_linebreak() (see "Notes" below).  Also
          note that the text may end without newline characters, or may end
          with extra characters (e.g. EOF).


Customization
=============

1. Customizing line breaking properties and rules

To customize line breaking classes, character width informations
or line breaking rules, read mklbproptab.py and relating files.

Note: linebreaktab.c, linebreaktab.h and linebreakrule.html are 
  generated by mklbproptab.py.  Don't edit these files manually.

2. Customizing support functins

Following built-in functions may be customized to meet the needs of your
application.

Note: Don't modify built-in support functions contained in
  unicode_linebreak.c.  Otherwise, write new functions then
  feed them as arguments of unicode_lbinfo_alloc() and/or
  unicode_linebreak().

* Argument 'flags' is bitwise options to customize behavior of these
  functions.  For more details see Option Flags.

unicode_lbprop_funcptr unicode_linebreak_find_lbprop_func(const char *chset,
                                                          int flags);

        Find a function to get character property suitable for
        specified charset `chset'.  If `chset' is NULL, length of `chset'
        is zero or appropriate function has not been found, a function
        unicode_find_lbprop_generic(), supporting generic context, should
        be returned. 

void unicode_linebreak_tailor_lbprop(unicode_char c,
                                     int *widthptr,
                                     enum unicode_lbclass *lbcptr,
                                     int flags);

        Sets customized width and line breaking class information of
        character c.
        `widthptr' and `lbcptr' are pointer to values of width and line
        breaking class.

int unicode_linebreak_check_length(struct unicode_lbinfo *lbinfo,
                                   unicode_char *text,
                                   off_t start, size_t len, int maxlen,
                                   void *voidarg);

        Returns boolean value indicating whether width (length) of text
        exceed `maxlen' or not.  `text' is buffer containing text fragment
        to check.  `start' and `textlen' are offset on `text' and length of
        text fragment.


Option Flags
============

#define UNICODE_LBOPTION_GENERIC_WIDTH           1

  Function: unicode_linebreak_find_lbprop_func()

  Resolve character width within generic (Unicode) context, even if
  character set context was specified.

#define UNICODE_LBOPTION_NARROW_LATIN            (1<<1)
#define UNICODE_LBOPTION_NARROW_GREEK            (1<<2)
#define UNICODE_LBOPTION_NARROW_CYRILLIC         (1<<3)

  Function: unicode_linebreak_tailor_lbprop()

  By default, in multibyte character set context, several Latin, Greek
  or Cyrillic letters are treated as Wide.  In some display
  enviroments they are usually rendered as Narrow, even if in
  multibyte context.  Set these options to treat such letters always
  Narrow.

#define UNICODE_LBOPTION_BREAK_HY                (1<<4)

  Function: unicode_linebreak_tailor_lbprop()

  Set this to allow break after HY (U+002D HYPHEN-MINUS), before AL.
  By default, breaking directly before AL is not allowed.

#define UNICODE_LBOPTION_BREAK_SOFT_HYPHEN       (1<<5)

  Function: unicode_linebreak_tailor_lbprop()

  Set this to allow break after U+00AD SOFT HYPHEN.  By default, breaking
  directly after soft hyphen is not allowed.

#define UNICODE_LBOPTION_NOBREAK_NL              (1<<6)

  Function: unicode_linebreak_tailor_lbprop()

  Set this to treat U+0085 NEL as CM, not BK. [UAX#14]

#define UNICODE_LBOPTION_NOBREAK_VT              (1<<7)

  Function: unicode_linebreak_tailor_lbprop()

  Set this to treat U+000B vertical tab as CM, not BK. [UAX#14]

#define UNICODE_LBOPTION_NOHUNG_PUNCT            (1<<8)

  Function: unicode_linebreak_tailor_lbprop()

  Set this to disable "burasage" (hunging punctuation in East Asian
  text).

#define UNICODE_LBOPTION_NOGLUE_PUNCT            (1<<9)

  Function: unicode_linebreak_tailor_lbprop()

  By default, Wide OP/CL characters are treated as if they are a
  Narrow character preceded/followed by SP.  Set this to disable
  such feature.

#define UNICODE_LBOPTION_IDSP_IS_SP              (1<<10)

  Function: unicode_linebreak_tailor_lbprop()

  By default, IDEOGRAPHIC SPACE is treated as ID.  Set this to treat
  it as SP.

#define UNICODE_LBOPTION_RELAX_KANA_NS           (1<<11)

  Function: unicode_linebreak_tailor_lbprop()

  By default, small hiragana/katakana and KATAKANA-HIRAGANA PROLONGED
  SIGN are NS.  Set this to treat these characters as ID. [JIS X 4051]

#define UNICODE_LBOPTION_OPAL_IS_AL              (1<<12)

  Function: unicode_linebreak_tailor_lbprop()

  Set this to treat spanish quotations INVERTED EXCLAMATION MARK and
  INVERTED QUESTION MARK as AL, not OP. [UAX#14]

#define UNICODE_LBOPTION_NOBREAK_DIRECT          (1<<13)

  Function: unicode_linebreak()

  Set this option to ommit Direct break oppotunities.
  WARNING: This may fold non-alphabetic (or mixed) texts *very* ugrily.

#define UNICODE_LBOPTION_NOCOMBINE_HANGUL_JAMO   (1<<14)

  Function: unicode_linebreak_check_length()

  Set this option not to combine hangul combining jamos (JT, JV, JL)
  when line lengths are determined.

#define UNICODE_LBOPTION_BREAK_SPCM              (1<<15)

  Function: unicode_linebreak()

  Set this to break SP+CM sequence. [UAX#14]

#define UNICODE_LBOPTION_FORCE_LINEWIDTH         (1<<16)

  Function: unicode_linebreak()

  Set this option to force break unbreakable text longer than specified
  width.  By default, longer text won't be broken.
  This violate line breaking rules then may cause break within words,
  syllables, characters or on somewhere unpreferred.

#define UNICODE_LBOPTION_DEFAULT                 0


Notes
=====

1. Newline characters and sequences

Lines broken by Explicit break oppotunity will end with each of
following characters or sequences:

    U+000A line feed (LF)
    U+000B vertical tab (VT) (optional.  See unicode_linebreak.h).
    U+000C form feed (FF).
    One or more U+000D carriage return (CR), not followed by LF.
    U+0085 new line function (NEL) (optional.  See unicode_linebreak.h).
    U+2028 LINE SEPARATOR (LS).
    U+2029 PARAGRAPH SEPARATOR (PS).
    And, one or more CR followed by LF.

2. Long lines

Sometimes lines longer than specified limit appear in output:

a) Sequence of SPACEs terminating Indirect break or sequences of newline
  (see above) terminating Explicit break won't be trimmed.  Line
  breaking algorithm employed by this module expects that SPACEs or newlines
  at end of line will be handled on application side.

b) Long character sequences in which no line break oppotunities found,
  for example Aopadotenachoselachogaleokranioleipsanodrimhipotrimmatosilphioparaomelitokatakechymenokichlepikossyphophattoperisteralektryonoptekephalliokigklopeleiolagoiosiraiobaphetraganopterygon.
  If you exactly shouldn't allow such pathological cases, Set
  UNICODE_LBOPTION_FORCE_LINEWIDTH on.

c) Tab stop processing is not supported by this module.  Holizontal tab
  will be always treated as a character width 1 column.

d) Hunging punctuation ("burasage") in East Asian text.  This will
  exceed up to one character width of limit.  For more detail read
  LineBreak/CharacterProperties.py, section about custom classes ``CLH''
  and ``CLHSP''.  To disable hunging punctuation, Set
  UNICODE_LBOPTION_NO_HUNGING_PUNCT on.

e) Similar case; Wide closing punctuations containing virtual glue.  These
  may exceed one column width of limit.  For more detail read
  LineBreak/CharacterProperties.py, section about custom classes ``CLSP''
  and ``CLHSP''.  To disable virtual glue of wide closing punctuations, Set
  UNICODE_LBOPTION_WIDE_PUNCT_WITHOUT_GLUE on.

f) Inappropriate assignment of character properties, or possiblly
  any characters not yet covered by this module.  If you found such a case,
  please inform me.


$$
